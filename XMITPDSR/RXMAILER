/******************************* REXX *********************************/
/*                                                                    */
/* RXMAILER a REXX batch mailer                                       */
/*                                                                    */
/*  Written June 2001 by                                              */
/*                                                                    */
/*  Paul Wells                                                        */
/*  Mainframe Systems Group                                           */
/*  Computer Operating System Division                                */
/*  Computer and Communication Systems Department                     */
/*  Saudi Aramco                                                      */
/*  Dhahran                                                           */
/*  Saudi Arabia                                                      */
/*                                                                    */
/*  +966-3-873-9505                                                   */
/*  wellspa@aramco.com.sa                                             */
/*                                                                    */
/**********************************************************************/
/* Modification History                                               */
/* --------------------                                               */
/*                                                                    */
/* Note: When amending, please change the version in the ver REXX     */
/*       variable.                                                    */
/*                                                                    */
/* Userid    Date         Comment                                     */
/* -------   ---------    --------------------------------------------*/
/* AWCPAW    2004/07/05 - Aramco domain names changed to aramco.com   */
/* AWCPAW    2003/04/22 - Mail data lines are split by CRLF before    */
/*                        being send to the server so as to avoid     */
/*                        exceeding the RFC defined limit for line    */
/*                        length.                                     */
/* AWCPAW    2003/04/14 - Four options for symbolic substitution -    */
/*                        SYMDATA, SYMSMTP, SYMALL, NOSYM.            */
/*                        SYMSMTP is the default option.              */
/*                      - CPU utilisation improvements in symbolic    */
/*                        substitution routines.                      */
/* AWCPAW    2003/04/05 - Added symbolic substitution which can       */
/*                        be performed in either the SMTP commands,   */
/*                        email SMTP header and the email body text.  */
/*                        For performance reasons the latter will     */
/*                        only be invoked when the SYMDATA parameter  */
/*                        is passed.                                  */
/*                      - Additional counters in termination messages */
/*                        indicating effect of symbolic substitution  */
/*                        (if any).                                   */
/*                      - Remove restriction on embeded blanks in     */
/*                        the parm string. This allows the RXMAILER   */
/*                        command to be split over multiple lines     */
/*                        in a batch job. Subparameters must still be */
/*                        separated by commas.                        */
/*                      - Enforced an RC=12 when an invalid           */
/*                        parameter is detected.                      */
/*                      - Rewrote socket read logic to just be a      */
/*                        single routine and to always read all       */
/*                        available data from the socket.             */
/* AWCPAW    2003/03/31 - New option SERVER= to specify the SMTP      */
/*                        server as an alternative to hardcoding      */
/*                        a list in the exec.                         */
/*                      - A special SMTP server name of *LOCAL*       */
/*                        can be used for the local system's SMTP     */
/*                        server.                                     */
/*                      - Improvements to retry and SMTP server list  */
/*                        processing.                                 */
/*                      - Close any open file left behind by the      */
/*                        retry logic.                                */
/*                      - New parameter HELO which allows the HELO    */
/*                        commands to be procesed if desired. However */
/*                        the timing of the server connects and HELOs */
/*                        is controlled by the exec and not input     */
/*                        file.                                       */
/* AWCPAW    2003/01/27 - Strip quotes from DSN= parameter to enable  */
/*                        use from ISPF 3.4.                          */
/* AWCPAW    2002/11/24 - If the 'From:' email address does not       */
/*                        contain an '@' then a valid email           */
/*                        address is generated and appended.          */
/* AWCPAW    2002/07/29 - Send end of data message after EOF if not   */
/*                        already sent to prevent hang.               */
/*                      - Jobname obtained via MVSVAR service not     */
/*                        via control blocks.                         */
/*                      - KB/MB/GB are multiples of 1000 not 1024     */
/* AWCPAW    2001/12/03 - Minor improvement to status message.        */
/* AWCPAW    2001/11/07 - CRLF to each command for NT Exchange server */
/* AWCP#W    2001/09/16 - DD parameter added.                         */
/* AWCP#W    2001/09/09 - Automatic internal restart from current     */
/*                        file position upon socket error up to limit */
/*                        of maxrty variable (suppressed for file     */
/*                        errors).                                    */
/*                      - Slight code tidy-up.                        */
/*                      - Save RC before clean-up processing.         */
/*                      - Correct check for TSO environment.          */
/* AWCP#W    2001/09/08 - Return code (retval) checking after most    */
/*                        socket calls.                               */
/* AWCP#W    2001/07/30 - Primary and alternate SMTP servers.         */
/*                      - GetHostByAddr call added to reverse resolve */
/*                        SMTP server address.                        */
/* AWCP#W    2001/07/29 - Minor improvements to statistics.           */
/*                      - Truncate ignored line echo.                 */
/*                      - SIMULATE or NOMAIL parameter to simulate    */
/*                        sending mails but not actually send them.   */
/* AWCP#W    2001/07/28 - Check for space delimited parameters (they  */
/*                        should be comma delimited).                 */
/*                      - Single line EXECIOs to limit storage use.   */
/* AWCP#W    2001/07/04 - Process QUIT commands.                      */
/*                      - Process RSET/NOOP correctly.                */
/* AWCP#W    2001/07/02 - Tidy up some debug messages.                */
/*                      - Ignore HELOs in the input file and send     */
/*                        our own.                                    */
/*                      - Allow SMTP commands in lower case.          */
/* AWCP#W    2001/07/01 - Status messages to track progress when      */
/*                        MSGLEVEL=1 is being used.                   */
/* AWCP#W    2001/06/30 - Suppress duplicate HELO commands if         */
/*                        still connected to prevent '503 bad         */
/*                        sequence' warning message.                  */
/*                      - Issue 'Exiting RC=' unconditionally.        */
/*                      - Echo smtpserver and maxmailbytes values at  */
/*                        start-up.                                   */
/*                      - Renumbered MSGLEVELs to add MSGLEVEL=1,     */
/*                        so old 1 becomes 2, 2 becomes 3 etc.        */
/* AWCP#W    2001/06/27 - Added MSGLEVEL parameter to control volume  */
/*                        of logging messages.                        */
/*                      - Echo parameters and MSGLEVEL at start-up.   */
/*                      - Added RESTART= parameter for restart        */
/*                        capability.                                 */
/*                      - Added statistics messages at termination.   */
/*                      - Comments relating to performance.           */
/* AWCP#W    2001/06/26 - Original version.                           */
/*                                                                    */
/**********************************************************************/
/* Program Description                                                */
/* -------------------                                                */
/* A REXX exec to forward emails from an input file direct to an      */
/* SMTP server on the network. The input file should already be in    */
/* SMTP format. This bypasses the SMTP server supplied with OS/390.   */
/* Unlike the OS/390 SMTP server this EXEC has no known data volume   */
/* limitations.                                                       */
/*                                                                    */
/* Customisation                                                      */
/* -------------                                                      */
/* 1) Specify the list of SMTP servers in the smtpserver.x            */
/*    rexx variables. (or use the SERVER= parameter)                  */
/* 2) Optional:                                                       */
/*    Specify the connection transmission limit in the maxmailbytes   */
/*    rexx variable. This threshold allows a disconnect/reconnect     */
/*    sequence to be issued when the specified number of bytes has    */
/*    been transmitted.                                               */
/* 3) Other optional customisation variables are the SMTP port,       */
/*    default message level, status statistics thereshold and error   */
/*    retries.                                                        */
/*                                                                    */
/* Input file format                                                  */
/* -----------------                                                  */
/* DSORG=PS RECFM=FB/VB any sensible LRECL (80-200 say)               */
/*                                                                    */
/* The input dataset can be passed as a DSN= parameter or             */
/* preallocated as the MAILDATA DD.                                   */
/*                                                                    */
/* It should contain any of the following SMTP commands:-             */
/* EHLO HELO RCPT RSET NOOP VRFY MAIL DATA                            */
/*                                                                    */
/* The input file can contain any number of emails.                   */
/*                                                                    */
/* An example input file looks like this:-                            */
/*                                                                    */
/* HELO SAOTOWER                                                      */
/* MAIL FROM:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>                         */
/* RCPT TO:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>                           */
/* DATA                                                               */
/* SENDER:  TROON                                                     */
/* IMPORTANCE: HIGH                                                   */
/* FROM:     DO NOT REPLY                                             */
/* TO:       WELLSPA@EXCHANGE.ARAMCO.COM.SA                           */
/* SUBJECT:  TROONIGAN TROONER                                        */
/* RUN DATE : 06/23/2001                                              */
/*                                                                    */
/* This is a test email.                                              */
/* .                                                                  */
/*                                                                    */
/* (The single period above indicates the end of the email data)      */
/*                                                                    */
/* Symbolic Substitution                                              */
/* ---------------------                                              */
/* Dynamic data, substituted at run-time and initiated by the use     */
/* of symbolics can be placed and will be substituted in any          */
/* of the following 3 places.                                         */
/*   1) SMTP commands e.g. MAIL, RCPT etc.                            */
/*   2) SMTP mail data header e.g. Sender: From: To: Subject:         */
/*   3) SMTP mail email data (only if the SYMDATA parameter is used   */
/*      os as to limit performance impact on jobs that don't need it) */
/* Symbloics available:-                                              */
/*   &HOST&     - host name                                           */
/*   &DOMAIN    - domain name                                         */
/*   &HOSTID&   - host IP address                                     */
/*   &JOBNAME&  - job name                                            */
/*   &USERID&   - security userid                                     */
/*   &USERNAME& - security name                                       */
/*   &JOBNUM&   - JES job number                                      */
/*   &PEERID&   - SMTP server IP address                              */
/*   &PEERNAME& - SMTP server name                                    */
/*   &SYSNODE&  - JES node                                            */
/*   &EXECNAME& - name of this exec                                   */
/*   &VERSION&  - version of this exec                                */
/*   &SYSNAME&  - system name                                         */
/*   &SYSSMFID& - SMF id                                              */
/*   &SYSOPSYS& - Operating system version                            */
/*   &SYSPLEX&  - SYSPLEX name                                        */
/*   &!tsocmd!& - Output of any TSO command (lines serarated by CRLFs)*/
/*   &!oecmd!&  - Output of any OMVS cmd (lines serarated by CRLFs)   */
/*   &!dsn!&    - Contents of any sequential dataset (CRLFs used)     */
/*   &!hfs!&    - Contents of any HFS dataset (CRLFs used)            */
/* Example:-                                                          */
/*   Helo &HOST&                                                      */
/*   Mail from:<&EXECNAME&@&HOST&.&DOMAIN&>                           */
/*   Rcpt to:<wellspa@aramco.com.sa>                                  */
/*   Data                                                             */
/*   Importance: high                                                 */
/*   X-Mailer: &EXECNAME& &VERSION& on &SYSNAME& running &SYSOPSYS&   */
/*   From: Job &JOBNAME&(&JOBNUM&) <&JOBNAME&@&HOST&.&DOMAIN&>        */
/*   Reply-to: &USERID&@&HOST&.&DOMAIN&                               */
/*   To: Recipient <&USERID&@&HOST&.&DOMAIN&>                         */
/*   Subject: Hello from &EXECNAME& &VERSION&                         */
/*   Date: &!left(date("W"),3)"," date() time() "LCL"!&               */
/*                                                                    */
/*   The sun has got his hat on, hip hip hip hooray.                  */
/*   The sun has got his hat on, and he's coming out today.           */
/*   Sent by &JOBNAME&(&JOBNUM&) from &HOST&.&DOMAIN&(&HOSTID&) at    */
/*   &!time()!& on &!date()!& using mail server &PEERNAME&(&PEERID&)  */
/*   User &USERID& is &USERNAME&                                      */
/*   &!TSO LISTC LVL('&USERID&')!&                                    */
/*   &!OE ls -al!&                                                    */
/*   &!HFS /etc/rc!&                                                  */
/*   &!DSN &USERID&.CBT.FILE600.REXX.PDS($CONTACT)!&                  */
/*   .                                                                */
/*                                                                    */
/* Execution                                                          */
/* ---------                                                          */
/* In TSO enter %RXMAILER DSN=dataset name                            */
/*                                                                    */
/* In batch use JCL like the following:-                              */
/*                                                                    */
/* //EMAIL    EXEC PGM=IKJEFT1B,PARM='%RXMAILER'                      */
/* //SYSEXEC  DD  DISP=SHR,DSN=CSD.CMDPROC                            */
/* //SYSTSPRT DD  SYSOUT=*                                            */
/* //SYSTSIN  DD  DUMMY                                               */
/* //MAILDATA DD  DISP=SHR,DSN=AWCP#W.TEST.MAIL                       */
/*                                                                    */
/* The return code will be 0 for success and non-zero to indicate     */
/* an error. A message in the SYSTSPRT will describe the error.       */
/*                                                                    */
/* Parameters                                                         */
/* ----------                                                         */
/* DSN=        - Specifies the input dataset if a preallocated        */
/*               MAILDATA is not to be used.                          */
/* DD=         - Specifies the input DD to be used if                 */
/*               MAILDATA is not to be used.                          */
/* MSGLEVEL=   - Specifies the level of messages to be output to      */
/*               SYSTSPRT. 1 is stats only, 2 is most transmissions,  */
/*               3 is more, 4 is full debug                           */
/* DEBUG       - Equivalent to MSGLEVEL=4 for comprehensive DEBUG     */
/*               messages in SYSTSPRT.                                */
/* RESTART=    - A line number from which to begin processing the     */
/*               input file.                                          */
/* SIMULATE    - Read input, connect to server, send HELO/MAIL/RCPT   */
/*               commands, but send RSET to cancel before             */
/*               sending mail. Allows testing of high volume input    */
/*               without actually sending the mails.                  */
/* NOMAIL      - Alias of SIMULATE.                                   */
/* SERVER=     - SMTP server name. Can be specified as an alternative */
/*               to those hardcoded in the exec.                      */
/* HELO        - Do not suppress HELO/EHLOs in the input file         */
/* SYMDATA     - Process symbolics in the mail data                   */
/* SYMSMTP     - Process symbolics in the SMTP commands and SMTP mail */
/*               header (default).                                    */
/* SYMALL      - Both SYMDATA and SYMSMTP.                            */
/* NOSYM       - Neither SYMDATA nor SYMSMTP.                         */
/*                                                                    */
/* When specifying multiple parameters, separate them by commas. e.g. */
/*                                                                    */
/*   MSGLEVEL=2,RESTART=100                                           */
/*                                                                    */
/* Messages                                                           */
/* --------                                                           */
/* Messages are logged in SYSTSPRT to indicate connection and         */
/* transmissions to server. e.g. with MSGLEVEL=3                      */
/*                                                                    */
/* RXMAILER: Entered as a TSO COMMAND at 14:41:45 on 26 Jun 2001, usin*/
/* g system TEST, by job AWCP#WEM (userid AWCP#W) and loaded from DD:S*/
/* YSEXEC.                                                            */
/*                                                                    */
/* RXMAILER: Connected to simsmail.aramco.com.sa -- Server ESMTP (Sun */
/* Internet Mail Server sims.4.0.1999.10.29.10.36.p4)                 */
/*                                                                    */
/* RXMAILER: Sent HELO SAOTOWER from line 1 of DD:MAILDATA            */
/* RXMAILER: Recv 250 simsmail.aramco.com.sa OK, tso03.dha.aramco.com.*/
/* RXMAILER: Sent MAIL FROM:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>          */
/* RXMAILER: Recv 250 2.5.0 Address Ok.                               */
/* RXMAILER: Sent RCPT TO:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>            */
/* RXMAILER: Recv 250 2.1.5 WELLSPA@EXCHANGE.ARAMCO.COM.SA OK.        */
/* RXMAILER: Sent DATA from line 4 of DD:MAILDATA                     */
/* RXMAILER: Recv 354 Enter mail, end with a single ".".              */
/* RXMAILER: Sent end of message for mail 1. 40 data lines (3512 bytes*/
/* RXMAILER: Recv 250 2.5.0 Ok.                                       */
/*                                                                    */
/*                                                                    */
/* Error messages usually contain a socket call description and a     */
/* return code. e.g.                                                  */
/*                                                                    */
/* RXMAILER: Connect RC=2016 EHOSTNOTFOUND Host not found in SITEINFO */
/* file                                                               */
/*                                                                    */
/* Socket errors can be diagnosed with the help of the                */
/* OS/390 SecureWay CS IP API Guide                                   */
/*                                                                    */
/* If these messages aren't enough for you, you can trace all the     */
/* socket calls using the DEBUG parameter to the EXEC. e.g.           */
/*                                                                    */
/* %RXMAILER DSN=dataset,DEBUG                                        */
/*                                                                    */
/* With DEBUG you will receive messages of the form :-                */
/*                                                                    */
/* RXMAILER DEBUG: Performing socket Fcntl BLOCKING                   */
/* RXMAILER DEBUG: Fcntl BLOCKING RC=0                                */
/* RXMAILER DEBUG: Performing socket Read                             */
/* RXMAILER DEBUG: Read RC=0 46 250 2.1.5 WELLSPA@EXCHANGE.ARAMCO.COM.*/
/*                                                                    */
/* Performance                                                        */
/* -----------                                                        */
/* This EXEC should perform considerably better than the OS/390 SMTP  */
/* server. 4-5 mails per second should be achievable. For             */
/* even better performance, put the REXX socket API in MLPA. This     */
/* eliminates the program load from the linklist of the 'socket'      */
/* module which occurs for every socket call. e.g.                    */
/*                                                                    */
/* SYS1.PARMLIB(IEALPA00) could additionally contain:-                */
/*                                                                    */
/*  /* TCPIP REXX socket API and aliases */                           */
/*  INCLUDE LIBRARY(SYS1.TCPIP.SEZALINK)                              */
/*          MODULES(EZBRXSOC,RXSOCKET,SOCKET,TCPERROR)                */
/*                                                                    */
/* or add dynamically by operator command:-                           */
/*                                                                    */
/*  SETPROG LPA,ADD,DSN=SYS1.TCPIP.SEZALINK,                          */
/*          MOD=(EZBRXSOC,RXSOCKET,SOCKET,TCPERROR)                   */
/*                                                                    */
/**********************************************************************/

 /* EXEC version - please change this when amending code */
 ver = "Version-05Jul04"

 /* smtpserver.x defines the network SMTP servers. */
 /* The SERVER= parameter can be used as an alternative. */
 smtpserver.1 = "exchange.aramco.com"
 smtpserver.2 = "mail.aramco.com"
 smtpserver.3 = "tso01.aramco.com"
 smtpserver.4 = "tso02.aramco.com"
 smtpserver.5 = "*LOCAL*"       /* Special value for local SMTP */

 /* standard smtp port - amend if neccessary */
 smtpport = 25

 /* maxmailbytes defines the threshold of transmitted bytes
    which triggers a disconnect/reconnect to the SMTP server.
    If the connection is to an OS390 or MVS SMTP server, the
    maxOS390mailbytes will be used. We prefer to use
    other faster servers higher up the smtpserver.x list. */
 maxmailbytes = 4*1024*1024
 maxOS390mailbytes = 524288 - 4096 /* default MAXMAILBYTES on OS/390 */

 /* default message level
    1 - Socket sends, selected socket receives, status messages
    2 - Socket sends, all socket receives, status messages
    3 - Socket sends, all socket receives, status messages,
        non-error return codes, diagnostic traces. Equivalent
        to DEBUG option                                        */
 dftmsglevel = 2

 /* Status message frequency. Issue progress message after defined
    number of mails */
 statthresh = 100

 /* DD name to use for dynamically allocated input */
 dynddn = "MA$LDA$A"

 /* Maximum retry count after error */
 maxrty = 5

/*--------------------------------------------------------------------*/

 parse arg parmsin

 parms = ""
 do mli1 = 1 to words(parmsin)   /* drop embedded spaces from parms */
   parms = parms||word(parmsin,mli1)
 end
 retval = 0
 savretval = 0

 parse source s1 s2 s3 s4 s5 s6 s7 s8 s9
 if ¬(abbrev(s8,"TSO")) & ¬(abbrev(s8,"ISPF")) then do
   say s3": Error - not running in TSO environment."
   say s3": Error - source string is "s1 s2 s3 s4 s5 s6 s7 s8 s9"."
   retval = 20
   signal theend
 end

 call ginit             /* general initialisation */
 if retval ¬= 0 then signal theend    /* quit if bad RC */

 call wmsg              /* call welcome message routine */

 call gpar              /* call parse parms routine */
 if retval ¬= 0 then signal theend    /* quit if bad RC */

 call adsn              /* call alloc DSN routine */
 if retval ¬= 0 then signal theend    /* quit if bad RC */

 call pmsg              /* call parm echo routine */

 call init              /* call init socket API routine */
 if retval ¬= 0 & reas ¬= "ESUBTASKALREADYACTIVE" then ,
  signal theend         /* quit if bad RC */

 call gdmn               /* call get domainname routine */

 do rcnt = 1 to maxrty + 1 /* Loop up to maxrty times to attempt
                              to send all of the data to SMTP server */
   if rcnt ¬= 1 then do /* first loop is not a restart */
     call snapstat      /* echo statistics so far */
     if conn then do
       call quit
       call shut
       call clos
     end
     /* don't check retval here in case socket already closed */
     conn = 0
     connbytectr = 0
     rstline = maillineno  /* set restart to start of current mail */
     intrst = 1            /* set internal restart flag */
     tmplinectr = plinectr - rstline + 1 + ignctr + orstline - 1
     plinectr = plinectr - tmplinectr /* no part processed mails */
     say
     say s3": Automatic restart from line "maillineno" generated."
   end

   call sdat                   /* call send data routine */

   if openf then do                  /* cleanup a possible open file */
     "EXECIO 0 DISKR "ddn" (FINIS)"   /* close file */
     openf = 0
   end

   if retval = 0 | nointrst then ,
    leave                      /* RC 0 means no need for restart,
                                  or no restart flag is set */
 end

 if retval ¬= 0 then do /* RC not zero and retries finished, */
   call crst            /* so determine restart point */
   savretval = retval   /* save RC for exit */
 end

 if conn then do        /* still connected ? */
   call quit            /* call send QUIT routine */
   call shut            /* call socket shut routine */
   call clos            /* call socket close routine */
 end

 call term              /* call terminate socket API routine */

 call tmsg              /* call terminating message routine */

 if ddn = dynddn then do
   if dbf then ,
    say s3||flag" Freeing input dataset DD:"ddn
   "FREE FI("ddn")"
 end

theend:

 if savretval ¬= 0 then retval = savretval
 if retval > 4 then errtxt = "ERROR "
 else errtxt = ""
 say
 say s3": Exiting "errtxt"RC="retval" at "time()" on "date()"."
 say

return retval


/* General initialisation */
ginit:

 sdate = date("B")
 stime = time("L")
 dbf = 0         /* debug flag */
 flag = ":"
 nointrst = 0    /* suppress internal restart flag */
 intrst = 0      /* internal restart flag */
 maillineno = 1  /* restart line number */
 conn = 0        /* connected to server flag */
 openf = 0       /* file open flag */
 retval = 0      /* return code */
 crlf = "0d25"x
 call syscalls "ON" /* Initialise OMVS variables */

 /* jobname from PSA(PSATOLD)->TCB(TCBTIO)->TIOT(TIOCNJOB) */
 /*jobn = ,
  strip(storage(c2x(storage(d2x(c2d(storage(21c,4))+12),4)),8))*/
 jobn = strip(mvsvar("SYMDEF","JOBNAME"))
 tcb = c2d(storage(21c,4))
 jstcb = c2d(storage(d2x(tcb+124),4))
 jscb = c2d(storage(d2x(jstcb+180),4))
 ssib = c2d(storage(d2x(jscb+316),4))
 jobnum = strip(storage(d2x(ssib+12),8))
 tcb = c2d(storage(21c,4))
 acee = c2d(storage(d2x(tcb+340),4))
 if acee = 0 then do
  ascb = c2d(storage(224,4))
  asxb = c2d(storage(d2x(ascb+108),4))
  acee = c2d(storage(d2x(asxb+200),4))
 end
 user = strip(storage(d2x(acee+21),8))
 if user = "" | left(user,1) = d2c(0) then ,
  user = strip(sysvar("SYSUID"))
 username = ""
 aceeunam = c2d(storage(d2x(acee+100),4))
 if aceeunam ¬= 0 then do
   aceeusrl = c2d(storage(d2x(aceeunam),1))
   if aceeusrl > 0 then ,
    username = strip(storage(d2x(aceeunam+1),aceeusrl-1))
 end

 address TSO
 "PROFILE MSGID WTPMSG" /* set msgid on to get TSO message ids */

 /* count SMTP servers */
 gi1 = 1
 if ¬(datatype(smtpserver.0,"W")) then do
   smtpserver.0 = 0
   do while smtpserver.gi1 ¬= "SMTPSERVER."gi1
     smtpserver.0 = gi1
     gi1 = gi1 + 1
   end
 end
 if smtpserver.0 = 0 then do
   say s3": Error - No SMTP servers defined in "s3" exec",
    "and SERVER= parameter not used."
   retval = 12
   return
 end

return


/* Welcome message routine */
wmsg:

 wmsg1 = s3":" ver" entered as a "s1 s2" at",
  time()" on "date()"."
 wmsg2 = s3": Using system "mvsvar("SYSNAME")","
 if jobn = user then ,
  wmsg3 = s3": Executing userid is "jobn"."
 else ,
  wmsg3 = s3": Executing job is "jobn" (userid "user")."
 if s5 = "?" then ,
  wmsg4 = "EXEC loaded from DD:"s4"."
 else ,
  wmsg4 = "EXEC loaded from DD:"s4" DSN:"s5"."

 say
 say wmsg1
 say wmsg3
 say wmsg2 wmsg4    /* issue welcome message */

return


pmsg:

 if parmstr = "" then parmstr = "(none)"
 say s3": Parameters - "parmstr"." /* show parameters */
 if pos("MSGLEVEL",parmstr) = 0 & msglevel = dftmsglevel then ,
  say s3": MSGLEVEL defaults to "dftmsglevel"." /* show MSGLEVEL */

 say s3": Input data from "inp"."     /* show input dataset */

 say s3": Primary SMTP server is "smtpserver.1"."
 say s3": Status message issued every "statthresh" mails."

 if simflag then do
   say
   say s3": Simulation only, no mails will be sent."
   say s3": Simulation only, no mails will be sent."
 end

return


/* Parse input parameters routine */
gpar:

 retval = 0      /* return code */
 parmstr = ""
 msglevel = dftmsglevel
 orstline = 1
 rstline = 1
 pctr = 1
 simflag = 0
 ddn = ""
 dsn = ""
 helosupp = 1
 helocmd = ""
 symdata = 0
 symsmtp = 1

 do while parms ¬= ""

   parse value parms with parm.pctr "," parms
   parm.pctr = strip(parm.pctr)
   parse upper value parm.pctr with parmu

   select

     when abbrev(parmu,"DSN=") then do
       if ddn ¬= "" then do
         say s3": Error - DSN parameter incompatible with DD."
         retval = 12
         return
       end
       dsn = strip(substr(parmu,5))
       dsn = strip(dsn,,"'")
       parmstr = parmstr||parmu","
     end

     when abbrev(parmu,"DD=") then do
       if dsn ¬= "" then do
         say s3": Error - DD parameter incompatible with DSN."
         retval = 12
         return
       end
       ddn = strip(substr(parmu,4))
       parmstr = parmstr||parmu","
     end

     when abbrev(parmu,"MSGLEVEL=") then do
       if pos("DEBUG",parmstr) > 0 then do
         say s3": Error - DEBUG parameter incompatible with MSGLEVEL."
         retval = 12
         return
       end
       msglevel = substr(parmu,10)
       if ¬(datatype(msglevel,"W")) then do
         say s3": Warning - non-integer "parm.pctr" ignored."
         msglevel = dftmsglevel
       end
       else if msglevel < 1 then do
         say s3": Warning - invalid "parm.pctr" assumed to be 1."
         msglevel = 1
       end
       else if msglevel > 4 then do
         say s3": Warning - invalid "parm.pctr" assumed to be 4."
         msglevel = 4
       end
       parmstr = parmstr"MSGLEVEL="msglevel","
     end

     when abbrev(parmu,"RESTART=") then do
       rstline = substr(parmu,9)
       if ¬(datatype(rstline,"W")) then do
         say s3": Error - non-integer "parm.pctr"."
         retval = 16
         return
       end
       else if rstline < 1 then do
         say s3": Error - invalid "parm.pctr"."
         retval = 16
         return
       end
       parmstr = parmstr"RESTART="rstline","
       orstline = rstline
     end

     /*when abbrev(parmu,"DEBUG") then do*/
     when parmu = "DEBUG" then do
       if pos("MSGLEVEL",parmstr) > 0 then do
         say s3": Error - DEBUG parameter incompatible with MSGLEVEL."
         retval = 12
         return
       end
       dbf = 1
       msglevel = 4
       flag = " DEBUG:"
       parmstr = parmstr||parmu","
     end

     when parmu = "SIMULATE" | parmu =  "NOMAIL" then do
       simflag = 1
       parmstr = parmstr||parmu","
     end

     when parmu = "HELO" then do
       helosupp = 0
       parmstr = parmstr||parmu","
     end

     when parmu = "SYMDATA" then do
       symdata = 1
       parmstr = parmstr||parmu","
     end

     when parmu = "SYMSMTP" then do
       symsmtp = 1
       parmstr = parmstr||parmu","
     end

     when parmu = "NOSYM" then do
       symsmtp = 0
       symdata = 0
       parmstr = parmstr||parmu","
     end

     when parmu = "SYMALL" then do
       symsmtp = 1
       symdata = 1
       parmstr = parmstr||parmu","
     end

     when abbrev(parmu,"SERVER=") then do
       smtpserver.1 = substr(parmu,8)
       smtpserver.0 = 1
       parmstr = parmstr||parmu","
     end

     otherwise do
       say s3": Error - unknown parameter '"parm.pctr"'."
       retval = 12
     end
   end

   pctr = pctr + 1

 end

 parmstr = strip(parmstr,"T",",")
 if msglevel = 4 then dbf = 1

return


/* Alloc input dataset routine */
adsn:

 retval = 0      /* return code */

 if dsn ¬= "" then do        /* DSN passed ? */

   inp = "DSN:"dsn
   if dbf then ,
    say s3||flag" Performing Alloc "inp

   ddn = dynddn
   msgstatus = MSG("OFF")
   "FREE FI("ddn")"
   null = MSG(msgstatus)

   "ALLOC FI("ddn") DA('"dsn"') SHR"
   retval = RC
   if dbf | retval ¬= 0 then ,
    say s3||flag "ALLOC DD:"ddn inp" RC="retval

 end
 else if ddn ¬= "" then do
   inp = "DD:"ddn
 end
 else do

   /* no DSN/DD passed, assume MAILDATA DD */
   inp = "DD:MAILDATA"
   ddn = "MAILDATA"

 end

return


/* Send data routine */
sdat:

 retval = 0      /* return code */
 indata = 0      /* got DATA command flag */
 indatahdr = 0   /* in DATA header command flag */
 gotmail = 0     /* mail flag */
 connbytectr = 0 /* connection bytes transmitted */
 maildatactr = 0 /* data lines in mail */
 mailbytectr = 0 /* data bytes in mail */
 if ¬(intrst) then do /* don't reset counters on internal restart */
   plinectr = 0    /* total processed lines */
   bytectr = 0     /* total bytes processed */
   readctr = 0     /* lines read */
   mailctr = 0     /* total mail counter */
   ignctr = 0      /* ignored lines counter */
   symbytectr = 0  /* net change in byte count after symbolics */
   symlinectr = 0  /* net change in line count after symbolics */
   rsymbctr = 0    /* set to zero in case symbolics not used */
   rsymlctr = 0    /* set to zero in case symbolics not used */
 end
 flctr = rstline - 1  /* current file line number */

 if rstline ¬= 1 then ,
  say s3": Restarting from line "rstline"."

 "EXECIO 0 DISKR "ddn rstline "(OPEN)"    /* open input file */
 retval = RC

 if dbf | retval ¬= 0 then ,
  say s3||flag "EXECIO open "inp" RC="retval
 if retval ¬= 0 then do
   nointrst = 1     /* suppress internal restart for open error */
   return
 end

 openf = 1

 /* Loop for every line in the dataset */
 do forever   /* do until eof */

   "EXECIO 1 DISKR "ddn" (LIFO)"  /* read 1 line from file */
   retval = RC

   if dbf | retval > 2 then ,
    say s3||flag "EXECIO read "inp" RC="retval

   if retval > 2 then do
     nointrst = 1     /* suppress internal restart for file error */
     return
   end
   else if retval = 2 then do

     if dbf then ,
      say s3||flag "EOF reached, closing "inp
     "EXECIO 0 DISKR "ddn" (FINIS)"   /* close file */
     openf = 0
     if rstline > 1 & readctr = 0 then do
       say s3": RESTART="rstline" invalid because input file does",
        "not have that many lines."
       nointrst = 1     /* suppress internal restart for file error */
       retval = 16
       return
     end
     else do
       retval = 0      /* EOF is normal so propagate a zero */
     end

     if indata then do /* must send end of data if data not ended */
       sv2retval = retval
       line = crlf||"."
       edverb = "Generated"
       call enddata
       retval = sv2retval
     end

     leave           /* eof reached - leave the forever loop */

   end

   parse pull line                      /* get data line from stack */
   flctr = flctr + 1                    /* increment curr line ctr */
   readctr = readctr + 1                /* increment read counter */
   line = strip(line,"T")               /* strip trailing blanks */
   len = length(line)
   parse upper value word(line,1) with cmd

   /* Select on the input data line */
   select

     /* End of data received. We expect a response so a blocking
        read is used. The indata flag is reset. */
     when (indata & line = ".") then do             /* must be 1st */
       edverb = "Sent"
       call enddata
     end

     /* For data lines we do not expect a response */
     when indata then do                            /* must be 2nd */
       if indatahdr & line = "" then indatahdr = 0

       /* Resolve symbolics for the data header */
       rsymlctr = 0 /* reset cos call to symbolics is conditional */
       rsymbctr = 0
       if indatahdr & symsmtp then line = resolve_symbolics(line)
       if ¬(indatahdr) & symdata then line = resolve_symbolics(line)

       /* Append a valid email address to the from name
          in case the SMTP server validates it */
       if indatahdr & abbrev(translate(line),"FROM:") &,
        pos("@",line) = 0 then do
         line = line" <"strip(jobn)"@"strip(hdmn)">"
       end

       if ¬(simflag) then do
         linespl = line
         do until linespl = ""
           parse var linespl linedat (crlf) linespl
           call wdat linedat     /* call write data routine */
           if retval ¬= 0 then return
         end
       end
       bytectr = bytectr + len        /* file byte counter increment
                                         before recompute line length */
       len = length(line)        /* recompute line length */
       symbytectr = symbytectr + rsymbctr
       symlinectr = symlinectr + rsymlctr
       maildatactr = maildatactr + 1 + rsymlctr
       mailbytectr = mailbytectr + len
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
     end

    /* MAIL command - we expect a definite response,
       but we also do a non-blocking read just in case there are
       extra response lines. */
     when cmd = "MAIL" then do                      /* must be 3rd */

       maillineno = flctr  /* restart line number */
       gotmail = 1
       if symsmtp then line = resolve_symbolics(line)

       /* Disconnect if maxmailbytes is exceeded to try to
          avoid any errors due to thresholds set in the server */
       if (connbytectr > currmaxmailbytes) & conn then do
         say s3": Transmitted bytes exceeds threshold ("||,
          currmaxmailbytes") - disconnecting temporarily."
         call snapstat "discon"     /* echo statistics so far */
         call quit
         call shut
         call clos
         /* don't check retval here in case socket already closed */
         conn = 0
         connbytectr = 0
       end

       /* Connect to server if not already connected. */
       if ¬(conn) then do
         call connr          /* call connect routine */
         if retval ¬= 0 then return /* return if no connect */
         conn = 1
         call shlo           /* call send HELO routine */
         if retval ¬= 0 then return
       end

       call wdat line        /* call write data routine */
       if retval ¬= 0 then return
       if msglevel > 1 then do
         say
         say s3": Sent "line" from line "flctr" of "inp"."
       end
       call readmchknum "250"
       if retval ¬= 0 then return
       symbytectr = symbytectr + rsymbctr
       symlinectr = symlinectr + rsymlctr
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
       bytectr = bytectr + len             /* add to proc byte count */

     end

     when cmd = "HELO" | cmd = "EHLO" then do       /* must be 4th */

       if symsmtp then line = resolve_symbolics(line)
       if helosupp then do
         ignctr = ignctr + 1
         if msglevel > 2 then ,
          say s3": Command '"line"' at line "flctr" not needed,",
           "so ignored."
       end
       else do
         helocmd = line
       end

     end

     when cmd = "QUIT" then do                     /* must be 5th */

       if conn then do
         call quit
         call shut
         call clos
         conn = 0
         connbytectr = 0
         plinectr = plinectr + 1
       end
       else do
         ignctr = ignctr + 1
         if msglevel > 2 then ,
          say s3": Command '"line"' at line "flctr" ignored",
           "(already quit)."
       end

     end

     /* No MAIL command received so we ignore lines in the file
        until we get one */
     when ¬(gotmail) then do                        /* must be 6th */

       say s3": Warning - ignored line starting '"substr(line,1,20)||,
        "' at line "flctr,
        "as no MAIL command received."
       ignctr = ignctr + 1

     end

     when cmd = "RSET" |,                          /* must be 7th */
      cmd = "NOOP" then do

       if symsmtp then line = resolve_symbolics(line)
       if cmd = "NOOP" then line = cmd  /* skip operands for noop */
       call wdat line        /* call write data routine */
       if retval ¬= 0 then return
       if msglevel > 1 then ,
        say s3": Sent "line
       call readmchknum "250"
       if retval ¬= 0 then return
       symbytectr = symbytectr + rsymbctr
       symlinectr = symlinectr + rsymlctr
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
       bytectr = bytectr + len             /* add to proc byte count */

     end

    /* DATA command - we expect a definite response,
       but we also do a non-blocking read all just in case there are
       extra response lines. The indata flag is set as following
       data lines will not get a response */
     when cmd = "DATA" then do

       indata = 1
       indatahdr = 1
       maildatactr = 0 /* data lines in mail */
       mailbytectr = 0 /* bytes in mail */
       if ¬(simflag) then do
         call wdat line        /* call write data routine */
         if retval ¬= 0 then return
         if msglevel > 1 then ,
          say s3": Sent "line
         call readmchknum "354"
         if retval ¬= 0 then return
       end
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
       bytectr = bytectr + len             /* add to proc byte count */

     end

    /* various commands - we expect a definite response,
       but we also do a non-blocking read just in case there are
       extra response lines. */
     when cmd = "RCPT" |,
      cmd = "VRFY" then do

       if symsmtp then line = resolve_symbolics(line)
       call wdat line        /* call write data routine */
       if retval ¬= 0 then return
       if msglevel > 1 then ,
        say s3": Sent "line
       call readmchknum "250 251 252"
       if retval ¬= 0 then return
       symbytectr = symbytectr + rsymbctr
       symlinectr = symlinectr + rsymlctr
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
       bytectr = bytectr + len             /* add to proc byte count */

     end

    /* other commands - we do a non-blocking read because we don't
       know if we will get a response */
     otherwise do

       call wdat line        /* call write data routine */
       if retval ¬= 0 then return
       say s3": Sent "line
       call readmsgs "NON-BLOCKING"
       if retval ¬= 0 then return
       if rddata ¬= "" & msglevel > 2 then ,
        say s3": Recv "rddata
       plinectr = plinectr + 1
       connbytectr = connbytectr + len     /* add to conn byte count */
       bytectr = bytectr + len             /* add to proc byte count */

     end

   end

 end

return


/* init socket API routine */
init:

 if dbf then do
   say
   say s3||flag" Performing socket Initialize"
 end
 rtvl = socket("Initialize",s3)
 parse var rtvl retval reas .
 if dbf | (retval ¬= 0 & reas ¬= "ESUBTASKALREADYACTIVE") then ,
  say s3||flag" Initialize RC="rtvl

return


/* socket init routine */
sock:

 if dbf then ,
  say s3||flag" Performing Socket"
 rtvl = socket("Socket",2,"STREAM",0)
 parse var rtvl retval reas .
 if retval = 0 then sockid = reas
 if dbf | retval ¬= 0 then ,
  say s3||flag" Socket RC="rtvl

return


/* socket set ASCII routine */
asci:

 if dbf then ,
  say s3||flag" Performing socket Setsockopt So_ASCII"
 rtvl = socket("Setsockopt",sockid,"Sol_Socket","So_ASCII","On")
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Setsockopt So_ASCII RC="rtvl

return


/* socket set block/non-block routine. A socket
   with the block option causes read socket calls to wait
   indefinitely for a response. */
blck:

 parse arg blopt

 if dbf then ,
  say s3||flag" Performing socket Fcntl "blopt
 rtvl = socket("Fcntl",sockid,"F_SETFL",blopt)
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Fcntl "blopt" RC="rtvl

return


/* socket connect retry wrapper routine. */
connr:

 sctr = 1

 do until (retval = 0 | sctr > smtpserver.0)

   if smtpserver.sctr = "*LOCAL*" then ,
    smtpserver.sctr = host"."domain
   call conns smtpserver.sctr
   if retval ¬= 0 then do
     sretval = retval
     call clos
     if sctr = smtpserver.0 then do
      cnrstr1 = "Error"
      cnrstr2 = "No more SMTP servers available to try."
     end
     else do
      cnrstr1 = "Warning"
      cnrstr2 = "Retrying with next one."
     end
     say s3": "cnrstr1" - Connect failed to SMTP server #"||,
      sctr smtpserver.sctr"." cnrstr2
     retval = sretval
   end
   sctr = sctr + 1

 end

 if retval ¬= 0 then return

 if wordpos("MVS",sav220) > 0 |,
  wordpos("OS390",sav220) > 0 |,
  wordpos("OS/390",sav220) > 0 |,
  wordpos("Z/OS",sav220) > 0 |,
  wordpos("z/OS",sav220) > 0 then do
   currmaxmailbytes = maxOS390mailbytes
   if msglevel > 1 then ,
    say s3||flag" OS/390 system detected, maximum bytes",
     "per connection set to "currmaxmailbytes" bytes."
 end
 else do
   currmaxmailbytes = maxmailbytes
   if msglevel > 1 then ,
    say s3||flag" Maximum bytes",
     "per connection set to "currmaxmailbytes" bytes."
 end

return


/* End of data routine. */
enddata:

 indata = 0
 indatahdr = 0
 gotmail = 0     /* mail flag */

 /* if simulation, then cancel existing transaction with
    RSET SMTP server command */
 if simflag then do
   call rset
   if retval ¬= 0 then return
 end
 else do
   call wdat line        /* call write data routine */
   if retval ¬= 0 then return
   if msglevel > 1 then ,
    say s3": "edverb" end of message for mail "mailctr+1".",
     maildatactr" data lines ("mailbytectr" data bytes)."
   call readmchknum "250"
   if retval ¬= 0 then return
 end

 mailctr = mailctr + 1
 plinectr = plinectr + 1
 connbytectr = connbytectr + len     /* add to conn byte count */
 bytectr = bytectr + len             /* add to proc byte count */

 if datatype(mailctr/statthresh,"W") then do
   call snapstat       /* snap statistics if threshold reached */
 end

return


/* socket connect routine. */
conns:

 parse arg cssrv
 sav220 = ""

 call sock                   /* call socket init routine */
 if retval ¬= 0 then return  /* quit if bad RC */

 call asci                   /* call socket set ASCII routine */
 if retval ¬= 0 then return  /* quit if bad RC */

 call gsoc                   /* call get socket info routine */
 call gcli                   /* call get client info routine */

 if dbf then ,
  say s3||flag" Performing socket Connect "cssrv
 rtvl = socket("Connect",sockid,"AF_INET "smtpport cssrv)
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Connect "cssrv" RC="rtvl
 if retval ¬= 0 then return

 /* definite response with 220 message expected from server */
 call readmchknum "220"
 if retval ¬= 0 then return
 say;say s3": Connected to "strip(subword(sav220,2))"."

 call gpee                   /* call get peer (server) info routine */
 if retval = 0 then ,        /* call gethostbyaddr info routine */
  call ghba

return


/* blocking read routine i.e. an indefinite wait for a reply from
   the server for 1st message then non-blocking reads subsequently */
readmsgs:

 parse arg rmsgp
 rddata = ""
 srvrc = ""

 if rmsgp ¬= "NON-BLOCKING" then do

   call blck "BLOCKING"
   if retval ¬= 0 then return

   if dbf then ,
    say s3||flag" Performing socket Read (blocking)"

   rtvl = socket("Read",sockid)
   parse var rtvl retval reas .
   if dbf | retval ¬= 0 then ,
    say s3||flag" Read RC="rtvl

   /* Data starts at 3rd word of response */
   if retval = 0 then do
     rddata = trns(subword(rtvl,3))
     srvrc = word(rddata,1)
   end
   else return

 end

 call blck "NON-BLOCKING"
 if retval ¬= 0 then return

 do forever          /* Loop until no more data */

   if dbf then ,
    say s3||flag" Performing socket Read (non-blocking)"
   rtvl = socket("Read",sockid)
   parse var rtvl retval reas .
   if dbf | (retval ¬= 0 & reas ¬= "EWOULDBLOCK" ) then ,
    say s3||flag" Read RC="rtvl
   if retval = 0 then do
     if reas = 0 then leave        /* exit for zero length data */
     rddata = rddata||trns(subword(rtvl,3))
   end
   else do
     if reas = "EWOULDBLOCK" then retval = 0
     leave
   end

 end

return


/* Send RSET to server routine */
rset:

 call wdat "RSET"            /* call write data routine */
 if retval ¬= 0 then return
 if msglevel > 2 then ,
  say s3": Sent RSET"
 call readmchknum "250"

return


/* Send QUIT to server routine */
quit:

 call wdat "QUIT"            /* call write data routine */
 if retval ¬= 0 then return
 if msglevel > 1 then do
  say
  say s3": Sent QUIT"
 end
 call readmsgs
 if retval ¬= 0 then return
 if (msglevel > 2 | srvrc ¬= "221") & rddata ¬= "" then ,
  say s3": Recv "rddata

return


/* Send HELO to server routine */
shlo:

 if helocmd = "" then helocmd = "HELO "hdmn
 call wdat helocmd                  /* call write data routine */
 if retval ¬= 0 then return
 if msglevel > 1 then ,
  say s3": Sent "helocmd
 call readmchknum "250"

return


/* socket write routine */
wdat:

 parse arg wddata
 if dbf then ,
  say s3||flag" Write" wddata
 rtvl = socket("Write",sockid,wddata||crlf)
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Write RC="rtvl

return


/* socket shut routine */
shut:

 if dbf then ,
  say s3||flag" Performing socket Shutdown"
 rtvl = socket("Shutdown",sockid,"BOTH")
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Shutdown RC="rtvl

return


/* socket close routine */
clos:

 if dbf then ,
  say s3||flag" Performing socket Close"
 rtvl = socket("Close",sockid)
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Close RC="rtvl
 if retval = 0 & peer ¬= "PEER" then do
   if ghbaname ¬= "" then extstr = " ("ghbaname")"
   else extstr = ""
   say s3": Closed socket to "peer||extstr"."
 end

return


/* socket API terminate routine */
term:

 if dbf then ,
  say s3||flag" Performing socket Terminate"
 rtvl = socket("Terminate")
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Terminate RC="rtvl

return


/* socket get peer info routine */
gpee:

 if dbf then ,
  say s3||flag" Performing socket Getpeername"
 rtvl = socket("Getpeername",sockid)
 parse var rtvl retval reas .
 if retval = 0 then peer = word(rtvl,4)
 if dbf | retval ¬= 0 then ,
  say s3||flag" Getpeername RC="rtvl

return


/* socket get socket name info routine */
gsoc:

 if dbf then ,
  say s3||flag" Performing socket Getsockname"
 rtvl = socket("Getsockname",sockid)
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Getsockname RC="rtvl

return


/* socket get client info routine */
gcli:

 if dbf then ,
  say s3||flag" Performing socket Getclientid"
 rtvl = socket("Getclientid")
 parse var rtvl retval reas .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Getclientid RC="rtvl

return


/* socket get domainname info routine */
gdmn:

 call ghst
 call ghid

 if dbf then ,
  say s3||flag" Performing socket Getdomainname"
 rtvl = socket("Getdomainname")
 parse var rtvl retval domain .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Getdomainname RC="rtvl
 if retval ¬= 0 then do
   domain = ""
   hdmn = sysvar("SYSNODE")
   retval = 0
 end
 else do
  if host = "" then hdmn = domain
  else hdmn = host"."domain
 end

return


/* socket get hostname info routine */
ghst:

 if dbf then ,
  say s3||flag" Performing socket Gethostname"
 rtvl = socket("Gethostname")
 parse var rtvl retval host .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Gethostname RC="rtvl
 if retval ¬= 0 then do
   host = ""
   retval = 0
 end

return


/* socket get hostid info routine */
ghid:

 if dbf then ,
  say s3||flag" Performing socket Gethostid"
 rtvl = socket("Gethostid")
 parse var rtvl retval hostid .
 if dbf | retval ¬= 0 then ,
  say s3||flag" Gethostid RC="rtvl
 if retval ¬= 0 then do
   hostid = "0.0.0.0"
   retval = 0
 end

return


/* socket get hostbyaddr info routine */
ghba:

 if pos(".",peer) = 0 then do
   ghbaname = ""
   if dbf then ,
    say s3||flag peer" not a valid IP address, GetHostByAddr skipped."
   retval = 0
   return
 end
 if dbf then ,
  say s3||flag" Performing socket GetHostByAddr "peer
 rtvl = socket("GetHostByAddr",peer)
 parse var rtvl retval ghbaname .
 if dbf | retval ¬= 0 then ,
  say s3||flag" GetHostByAddr RC="rtvl
 if retval ¬= 0 then do
   ghbaname = ""
   retval = 0
 end

return


/* terminating message routine */
tmsg:

 retval = 0

 lsecs = getlsecs()

 lhrs = lsecs % (60*60)
 if lhrs > 0 then do
   rsecs = lsecs // (60*60)
   lmins = rsecs % 60
   rsecs = rsecs // 60
   if lhrs = 1 then hrstr = ""
   else hrstr = "s"
   if lmins = 1 then minstr = ""
   else minstr = "s"
   lstr = lhrs" hour"hrstr" "lmins" minute"minstr,
    format(rsecs,,1)||" seconds."
 end
 else do
   lmins = lsecs % 60
   if lmins > 0 then do
     rsecs = lsecs // 60
     if lmins = 1 then minstr = ""
     else minstr = "s"
     lstr = lmins" minute"minstr,
      format(rsecs,,1)||" seconds."
   end
   else do
     lstr = format(lsecs,,1)||" seconds."
   end
 end

 mailrate = format(mailctr/lsecs,,1)
 byterate = (bytectr+symbytectr)/lsecs
 if byterate > 1000*1000 then ,
   brstr = format(byterate/(1000*1000),,2)||" total Mbytes/sec."
 else if byterate > 1000 then ,
   brstr = format(byterate/1000,,1)||" total Kbytes/sec."
 else ,
   brstr = format(byterate,,0)||" total bytes/sec."

 if ignctr > 0 & orstline = 1 then ,
  igndata = " (plus "ignctr" ignored)"
 else if ignctr > 0 & orstline > 1 then ,
  igndata = " (plus "ignctr" ignored, "orstline-1" skipped)"
 else if ignctr = 0 & orstline > 1 then ,
  igndata = " (plus "orstline-1" skipped)"
 else ,
  igndata = ""

 say
 if simflag then do
   simstr = "Simulated "
   simstr1 = "Simulated elapsed"
   simstr2 = "Simulated performance"
   say s3": Simulation only, no mails sent, following statistics",
    "reflect simulated performce only."
   say s3": Simulation only, no mails sent, following statistics",
    "reflect simulated performce only."
   say
 end
 else do
   simstr = ""
   simstr1 = "Elapsed"
   simstr2 = "Performance"
 end


 bcstr = fmtbyte(bytectr,"file ")

 if mailctr = 1 then mcp = ""
 else mcp = "s"
 say s3": "simstr||mailctr" mail"mcp||,
  ", "plinectr" file lines"igndata",",
  bcstr" processed."
 if symbytectr ¬= 0 then do
   if symbytectr < 0 then symbytestr = "removed"
   else symbytestr = "added"
   say s3": Symbolic substitution",
    symbytestr fmtbyte(symbytectr)"."
 end

 if mailctr = 0 then retval = 4
 else do
   say s3": "simstr1" time "lstr
   say s3": "simstr2" "mailrate,
    "mails/sec, "brstr
 end

return


fmtbyte:

 parse arg fmtbyte,fmtext

 if fmtbyte > 1000*1000*1000 then ,
   fbstr = format(fmtbyte/(1000*1000*1000),,3) fmtext"Gbytes"
 else if fmtbyte > 1000*1000 then ,
   fbstr = format(fmtbyte/(1000*1000),,2) fmtext"Mbytes"
 else if fmtbyte > 1000 then ,
   fbstr = format(fmtbyte/1000,,1) fmtext"Kbytes"
 else ,
   fbstr = format(fmtbyte,,0) fmtext"bytes"

return fbstr


/* resolve symbolics in commands, data header and data */
resolve_symbolics:

 parse arg rsyml

 if pos("&",rsyml) = 0 then return rsyml /* extra check saves CPU */
 rssav = rsyml

 rsymnm.1  = "&HOST&"    ; rsymvl.1  = host
 rsymnm.2  = "&DOMAIN&"  ; rsymvl.2  = domain
 rsymnm.3  = "&HOSTID&"  ; rsymvl.3  = hostid
 rsymnm.4  = "&JOBNAME&" ; rsymvl.4  = jobn
 rsymnm.5  = "&USERID&"  ; rsymvl.5  = user
 rsymnm.6  = "&USERNAME&"; rsymvl.6  = username
 rsymnm.7  = "&JOBNUM&"  ; rsymvl.7  = jobnum
 rsymnm.8  = "&PEERID&"  ; rsymvl.8  = peer
 rsymnm.9  = "&PEERNAME&"; rsymvl.9  = ghbaname
 rsymnm.10 = "&SYSNODE&" ; rsymvl.10 = sysvar("SYSNODE")
 rsymnm.11 = "&EXECNAME&"; rsymvl.11 = s3
 rsymnm.12 = "&VERSION&" ; rsymvl.12 = ver
 rsymnm.13 = "&SYSNAME&" ; rsymvl.13 = mvsvar("SYSNAME")
 rsymnm.14 = "&SYSSMFID&"; rsymvl.14 = mvsvar("SYSSMFID")
 rsymnm.15 = "&SYSOPSYS&"; rsymvl.15 = mvsvar("SYSOPSYS")
 rsymnm.16 = "&SYSPLEX&" ; rsymvl.16 = mvsvar("SYSPLEX")

 rsyml = rsym2(rsyml)

 /* process REXX and TSO commands after substitution of variables */
 signal on syntax name resolve_symbolics_err
 rsyml = rsym3(rsyml)
 signal off syntax
 signal resolve_symbolics_cont

resolve_symbolics_err:
 say s3": REXX error "RC" in line "SIGL" : "errortext(RC)
 say s3": "strip(sourceline(SIGL),"T")
 say s3": Warning, substitution of &!CMDS& in line "flctr "caused a",
  "REXX error: "rsyml

resolve_symbolics_cont:
  if dbf & rssav ¬= rsyml then do
    say s3||flag" Line "flctr" before substitution: "rssav
    say s3||flag" Line "flctr" after substitution:  "rsyml
  end

  rsymlctr = 0
  rsymbctr = length(rsyml)
  do rsymi1 = 1 to rsymbctr          /* count the CRLFs */
    if abbrev(substr(rsyml,rsymi1),crlf) then ,
     rsymlctr = rsymlctr + 1
  end
  rsymbctr = rsymbctr - length(rssav) /* compute net increase in bytes*/
  retval = 0

return rsyml


/* substitute static symbolics */
rsym2:

 parse arg r2in

 r2rt = ""
 do r2i1 = 1 to length(r2in)
   r2remstr = substr(r2in,r2i1)
   if abbrev(r2remstr,"&") then do    /* this extra check saves CPU */
     r2i2 = 1
     do until rsymnm.r2i2 = "RSYMNM."r2i2
       r2fr = rsymnm.r2i2
       r2to = rsymvl.r2i2
       if abbrev(r2remstr,r2fr) then do
         r2rt = r2rt||r2to
         r2i1 = r2i1 + length(r2fr) - 1
         iterate r2i1
       end
       r2i2 = r2i2 + 1
     end
   end
   /*r2rt = r2rt||substr(r2in,r2i1,1)*/
   r2rt = r2rt||substr(r2remstr,1,1)
 end

return r2rt


/* substitute command and REXX symbolics */
rsym3:

 parse arg r3in

 if pos("&!",r3in) = 0 then return r3in /* this extra check saves CPU */
 r3rt = ""
 do r3i1 = 1 to length(r3in)
   r3remstr = substr(r3in,r3i1)
   if abbrev(r3remstr,"&!") then do
     r3ecpos = pos("!&",substr(r3remstr,2))
     if r3ecpos > 0 then do
       r3exc = substr(r3remstr,3,r3ecpos-2)
       if abbrev(r3remstr,"&!TSO ") then do
         r3exc = substr(r3exc,5)
         r3cmdout = rsymtso(r3exc)
       end
       else if abbrev(r3remstr,"&!DSN ") then do
         r3exc = substr(r3exc,5)
         r3cmdout = rsymdsn(r3exc)
       end
       else if abbrev(r3remstr,"&!OE ") then do
         r3exc = substr(r3exc,4)
         r3cmdout = rsymoe(r3exc)
       end
       else if abbrev(r3remstr,"&!HFS ") then do
         r3exc = substr(r3exc,5)
         r3cmdout = rsymhfs(r3exc)
       end
       else ,
        interpret "r3cmdout = "r3exc
       r3rt = r3rt||r3cmdout
       r3i1 = r3i1 + r3ecpos + 1
       iterate
     end
   end
   r3rt = r3rt||substr(r3remstr,1,1)
 end

return r3rt


/* TSO command substitution */
rsymtso:

 parse arg rstc

 rstret = rstc||crlf
 rstmsg = msg("ON")
 drop rstout.
 rsdum = outtrap("rstout.")
 address TSO rstc
 do rsti1 = 1 to rstout.0
   rstret = rstret||rstout.rsti1||crlf
 end
 rsdum = outtrap("OFF")
 x = msg(rstmsg)

return rstret


/* DSN substitution */
rsymdsn:

 parse arg rsdsc

 rsdsc = strip(rsdsc,,"'")
 rsdsret = rsdsc||crlf
 rsdsdd = "R$X"right(random(99999),5,"0")
 rsdsmsg = msg("ON")
 drop rsdscmdout.
 rsdum = outtrap("rsdscmdout.")
 address TSO

 "ALLOC FI("rsdsdd") DA('"rsdsc"') SHR"
 if RC ¬ = 0 then do
   rsdsret = rsdsret"ALLOC for "rsdsc" failed RC="RC||crlf
   do rsdsi1 = 1 to rsdscmdout.0
     rsdsret = rsdsret||rsdscmdout.rsdsi1||crlf
   end
   signal rsymdsnret
 end

 drop rsdsout.
 "EXECIO * DISKR "rsdsdd" (STEM rsdsout. FINIS)"
 if RC ¬ = 0 then do
   rsdsret = rsdsret"EXECIO read of "rsdsc" failed RC="RC||crlf
   do rsdsi1 = 1 to rsdscmdout.0
     rsdsret = rsdsret||rsdscmdout.rsdsi1||crlf
   end
   signal rsymdsnret
 end

 do rsdsi1 = 1 to rsdsout.0
   rsdsret = rsdsret||rsdsout.rsdsi1||crlf
 end

rsymdsnret:
 rsdum = outtrap("OFF")
 x = msg("OFF")
 "FREE FI("rsdsdd")"
 x = msg(rsdsmsg)

return rsdsret


/* OE command substitution */
rsymoe:

 parse arg rsoec

 rsoec.1 = "/bin/sh"
 rsoec.2 = "-Lc"
 rsoec.3 = rsoec
 rsoec.0 = 3

 rsoepw. = ""
 address syscall "getpwnam "user" rsoepw."
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall getpwnam "user)
   signal rsymoeret
 end
 if ¬(abbrev(rsoepw.pw_dir,"/")) then rsoepw.pw_dir = "/tmp"

 rsoeev.1 = "_BPX_SHAREAS=YES"
 rsoeev.2 = "HOME="rsoepw.pw_dir
 rsoeev.3 = "LOGNAME="user
 rsoeev.0 = 3

 rsoeret = rsoec||crlf
 rsoeshout = "/tmp/"user"."time("L")"."s3"."random(99999)

 address syscall "open /dev/null "O_RDONLY 000
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall open /dev/null")
   signal rsymoeret
 end
 rsoefd.0 = retval

 address syscall "creat (rsoeshout) 700"
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall creat "rsoeshout)
   signal rsymoeret
 end
 rsoefd.1 = retval
 rsoefd.2 = retval

 address syscall "spawnp (rsoec.1) 3 rsoefd. rsoec. rsoeev."
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall spawnp "rsoec.1)
   signal rsymoeret
 end

 rsoepid = retval

 address syscall "waitpid (rsoepid) rsoest. 0"
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall waitpid "rsoepid)
   signal rsymoeret
 end

 address syscall "fstat (rsoefd.1) rsoestat."
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rsoeret = rsoeret||rsymoeerr("syscall fstat "rsoefd.1)
   signal rsymoeret
 end
 address syscall "close "rsoefd.1
 rsoefd.1 = ""             /* prevent double close */

 if rsoestat.st_size > 0 then do
   address syscall "readfile (rsoeshout) rsoeout."
   if RC < 0 | (RC >= 0 & retval = -1) then do
     rsoeret = rsoeret||rsymoeerr("syscall readfile "rsoeshout)
     signal rsymoeret
   end
   do rsoei1 = 1 to rsoeout.0
     rsoeret = rsoeret||rsoeout.rsoei1||crlf
   end
 end

rsymoeret:
 if datatype(rsoefd.0,"W") then do
   address syscall "close "rsoefd.0
 end
 if datatype(rsoefd.1,"W") then do
   address syscall "close "rsoefd.1
 end
 if datatype(rsoefd.2,"W") then do
   address syscall "unlink (rsoeshout)"
 end

return rsoeret


/* HFS substitution */
rsymhfs:

 parse arg rshfc

 rshfret = rshfc||crlf
 address syscall "readfile (rshfc) rshfout."
 if RC < 0 | (RC >= 0 & retval = -1) then do
   rshfret = rshfret||rsymoeerr("syscall readfile "rshfc)
   signal rsymhfsret
 end
 do rshfi1 = 1 to rshfout.0
   rshfret = rshfret||rshfout.rshfi1||crlf
 end

rsymhfsret:

return rshfret


rsymoeerr:

 parse arg rsoeet

 rsoeet = rsoeet||" error RC="RC
 if retval = -1 then do
  rsoeet = rsoeet||" Errno="errno "Errnojr="right(errnojr,8,"0")||crlf
  address syscall "strerror "errno errnojr" rsoeerr."
  do rsoeei1 = 1 to rsoeerr.0
    rsoeet = rsoeet||rsoeerr.rsoeei1||crlf
  end
 end

return rsoeet


/* echo status statistics */
snapstat:

 parse arg ssentry

 if ssentry = "discon" then ssmrstr = ,
  " ("format(mailctr/getlsecs(),,1)" per sec)"
 else ,
  ssmrstr = ""

 if mailctr = 1 then mcp = ""
 else mcp = "s"

 bcstr = fmtbyte(bytectr+symbytectr,"total ")
 say s3": Status - "mailctr" mail"mcp||ssmrstr", "plinectr,
  "file lines, "bcstr" processed."

return


/* read multiple messages and check numeric reply code from server */
readmchknum:

 parse arg chknum
 retval = 0

 call readmsgs

 if retval ¬= 0 then return
 if srvrc = "220" then ,
  sav220 = rddata
 if msglevel > 2 | wordpos(srvrc,chknum) = 0 then ,
   say s3": Recv "rddata
 if wordpos(srvrc,chknum) = 0 then do
   say s3": Error unexpected response "srvrc" from server, expecting",
    chknum
   if datatype(srvrc,"W") then ,
    retval = srvrc
   else ,
    retval = 999
   return
 end

return


/* check recommended restart line and echo it */
crst:

 say
 say s3": An error has occurred and the maximum retry count of "maxrty,
  "has been exceeded, or retry is not allowed."
 say s3": See prior messages for diagnosis."
 if mailctr = 0 then do
   if rstline = 1 then ,      /* message only if no restart */
    say s3": Restart using entire input dataset.",
     "i.e. do not specify RESTART= parameter to "s3"."
 end
 else do
   if mailctr = 1 then mcp = ""
   else mcp = "s"
   say s3": "mailctr" mail"mcp" ("maillineno-1,
    "lines) already processed."
   say s3": To avoid duplicate sends, specify",
    "parameter RESTART="maillineno" to "s3" on this",
    "step for re-run."
 end

return


getlsecs:

 ssecs = (substr(stime,1,2)*60*60) + ,
  (substr(stime,4,2)*60) + substr(stime,7)
 edate = date("B")
 etime = time("L")
 esecs = (substr(etime,1,2)*60*60) + ,
  (substr(etime,4,2)*60) + substr(etime,7)

 if edate = sdate then do
   lsecs = esecs - ssecs
 end
 else do
   extsecs = (edate - sdate - 1) * 60*60*24
   lsecs = extsecs + ((60*60*24)-ssecs) + esecs
 end

return lsecs


/* Translate CRLF to spaces and square brackets to normal
   brackets to make them printable. */
trns:

 parse arg trnsarg
 trnsretval = translate(trnsarg,"  ()","0d25adbd"x)

return trnsretval

